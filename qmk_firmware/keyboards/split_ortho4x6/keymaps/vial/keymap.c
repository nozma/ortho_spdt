// Generated by Vial Keymap C Editor (https://vial-keymap-c-editor.pages.dev)

#include QMK_KEYBOARD_H

#ifdef QMK_SETTINGS
#include "qmk_settings.h"
#endif

/* USER INCLUDE BEGIN */
#include "quantum.h"
#include "pointing_device.h"
#include <stdint.h>
#include <stdbool.h>
#include <stdlib.h> // abs
/* USER INCLUDE END */

/* GENERATED CODE BEGIN */

const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
    [0] = LAYOUT(
                /* 左手側 */
                   KC_Q,            KC_W,            KC_E,            KC_R,            KC_T,                QK_BOOT,      
                   LT(3,KC_A),      KC_S,            KC_D,            KC_F,            KC_G,                KC_NO,
                   LSFT_T(KC_Z),    KC_X,            KC_C,            KC_V,            KC_B,     
                   KC_LEFT_GUI,                                       KC_LEFT_ALT,     LT(1,KC_LANGUAGE_2), LT(5,KC_ENTER),        
                /* 右手側 */
                QK_BOOT,            
                   KC_Y,            KC_U,            KC_I,            KC_O,            KC_P,  
                KC_NO,
                   KC_H,            KC_J,            KC_K,            LT(4,KC_L),      KC_SEMICOLON,            
                   KC_N,            KC_M,            KC_COMMA,        KC_DOT,          RSFT_T(KC_SLASH),  
                   LT(6,KC_SPACE),     LT(2,KC_LANGUAGE_1),                            KC_ESCAPE
    ),
    [1] = LAYOUT(
                /* 左手側 */
                   KC_ESCAPE,       (QK_LGUI|KC_W),  (QK_LGUI|KC_E),  (QK_LGUI|KC_R),  (QK_LGUI|KC_T),       KC_TRANSPARENT,  
                   (QK_LGUI|KC_A),  (QK_LGUI|KC_S),  (QK_LGUI|KC_D),  (QK_LGUI|KC_F),  (QK_LGUI|KC_G),       KC_TRANSPARENT,
                   (QK_LGUI|KC_Z),  (QK_LGUI|KC_X),  (QK_LGUI|KC_C),  (QK_LGUI|KC_V),  (QK_LGUI|KC_B),  
                   KC_TRANSPARENT,                                    KC_TRANSPARENT,  KC_TRANSPARENT,       (QK_LGUI|KC_ENTER),  
                /* 右手側 */
                KC_TRANSPARENT,  
                   (QK_LSFT|KC_6),  (QK_LSFT|KC_7),  (QK_LSFT|KC_8),  (QK_LSFT|KC_9),  KC_MINUS, 
                KC_TRANSPARENT,
                   (QK_LGUI|KC_H),  (QK_LGUI|KC_J),  (QK_LGUI|KC_K),  (QK_LGUI|KC_L),  KC_EQUAL,
                   (QK_LGUI|KC_N),  (QK_LGUI|KC_M), (QK_LGUI|KC_COMMA),(QK_LGUI|KC_DOT), (QK_LSFT|KC_INTERNATIONAL_1), 
                   (QK_LGUI|KC_SPACE),  KC_TRANSPARENT,                                KC_TRANSPARENT
    ),
    [2] = LAYOUT(
                /* 左手側 */
                   KC_1,            KC_KP_2,         KC_KP_3,         KC_KP_4,         KC_KP_5,              KC_TRANSPARENT,
                   KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,       KC_TRANSPARENT,
                   KC_LEFT_SHIFT,   KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  
                   KC_TRANSPARENT,                                    KC_TRANSPARENT,  KC_TRANSPARENT,       KC_TRANSPARENT, 
                /* 右手側 */
                KC_TRANSPARENT,     
                   KC_KP_6,         KC_KP_7,         KC_KP_8,         KC_KP_9,         KC_KP_0,  
                KC_TRANSPARENT,
                   KC_LEFT,         KC_DOWN,           KC_UP,        KC_RIGHT,         KC_TRANSPARENT,  
                   KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT, KC_TRANSPARENT,   KC_RIGHT_SHIFT,  
                   KC_TRANSPARENT,  KC_TRANSPARENT,                                    KC_TRANSPARENT
    ),
    [3] = LAYOUT(
                /* 左手側*/
                   KC_Q,            (QK_LCTL|KC_W),  (QK_LCTL|KC_E),  (QK_LCTL|KC_R),  (QK_LCTL|KC_T),        KC_TRANSPARENT,  
                   KC_TRANSPARENT,  (QK_LGUI|KC_LEFT),(QK_LCTL|KC_D),  KC_RIGHT,       (QK_LCTL|KC_G),        KC_TRANSPARENT,
                   (QK_LCTL|KC_Z),  (QK_LCTL|KC_X),  (QK_LCTL|KC_C),  (QK_LCTL|KC_V),  KC_LEFT,  
                   KC_TRANSPARENT,                                    KC_TRANSPARENT,  KC_TRANSPARENT,       (QK_LCTL|KC_ENTER),  
                /* 右手側 */
                KC_TRANSPARENT,  
                   (QK_LCTL|KC_Y),  (QK_LCTL|KC_U),  (QK_LCTL|KC_I),  (QK_LCTL|KC_O),  KC_UP,
                KC_TRANSPARENT,
                   KC_BACKSPACE,    (QK_LCTL|KC_J),  (QK_LCTL|KC_K),  (QK_LCTL|KC_L),  (QK_LCTL|KC_SEMICOLON),        
                   KC_DOWN,         (QK_LCTL|KC_M),  (QK_LCTL|KC_COMMA),(QK_LCTL|KC_DOT),(QK_LCTL|KC_SLASH),
                   (QK_LCTL|KC_SPACE),  KC_TRANSPARENT,                                 KC_TRANSPARENT
    ),
    [4] = LAYOUT(
                /* 左手側 */
                   KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,
                   KC_LEFT_CTRL,    KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,
                   KC_LEFT_SHIFT,   KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  
                   KC_TRANSPARENT,                                    KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  
                /* 右手側 */
                KC_TRANSPARENT, 
                   (QK_LCTL|KC_BACKSLASH), (QK_LCTL|QK_LGUI|KC_I),    KC_MISSION_CONTROL,  (QK_LSFT|KC_L),  KC_TRANSPARENT,  
                KC_TRANSPARENT,
                   (QK_LSFT|KC_H),      KC_MS_BTN1,      KC_MS_BTN2,  KC_TRANSPARENT,  KC_TRANSPARENT,  
                   KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,
                   KC_TRANSPARENT,  KC_TRANSPARENT,                                    KC_TRANSPARENT
    ),
    [5] = LAYOUT(
                 /* 左手側 */
                    KC_ESCAPE,      KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  
                    KC_TRANSPARENT, KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,
                    KC_LEFT_SHIFT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  
                    KC_TRANSPARENT,                                   KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  
                /* 右手側*/
                KC_TRANSPARENT, 
                    KC_TRANSPARENT,  KC_TRANSPARENT, KC_TRANSPARENT, (QK_LSFT|KC_RIGHT_BRACKET), KC_RIGHT_BRACKET,
                KC_TRANSPARENT,
                    KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT, (QK_LSFT|KC_BACKSLASH),   KC_BACKSLASH,  
                    KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT, (QK_LSFT|KC_INTERNATIONAL_1),  
                    KC_TRANSPARENT,  KC_TRANSPARENT,                                   KC_TRANSPARENT
    ),
    [6] = LAYOUT(
               /* 左手側 */
                    KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT, 
                    KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,
                    KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  
                    KC_TRANSPARENT,                                    KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  
                /* 右手側 */
                KC_TRANSPARENT,
                    KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT, (QK_LSFT|KC_LEFT_BRACKET), KC_LEFT_BRACKET, 
                KC_TRANSPARENT,
                    KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  (QK_LSFT|KC_QUOTE),  
                    KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_INT1,  
                    KC_TRANSPARENT,  KC_TRANSPARENT,                                    KC_TRANSPARENT
    ),
    [7] = LAYOUT(
                /* 左手側*/
                    KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  
                    KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,
                    KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,
                    KC_TRANSPARENT,                                    KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,
                /* 右手側 */
                KC_TRANSPARENT,
                    KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,
                KC_TRANSPARENT,
                    KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  
                    KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  KC_TRANSPARENT,  
                    KC_TRANSPARENT,  KC_TRANSPARENT,                                    KC_TRANSPARENT
    )
};

#if defined(ENCODER_MAP_ENABLE)
const uint16_t PROGMEM encoder_map[][NUM_ENCODERS][NUM_DIRECTIONS] = {
};
#endif

// Tap Dance definitions
#define TAP_DANCE_ENTRY(onTap, onHold, onDoubleTap, onTapHold, tappingTerm) ((vial_tap_dance_entry_t){.on_tap = onTap, .on_hold = onHold, .on_double_tap = onDoubleTap, .on_tap_hold = onTapHold, .custom_tapping_term = tappingTerm})
#if VIAL_TAP_DANCE_ENTRIES > 0
const vial_tap_dance_entry_t default_tap_dance_entries[] = {
    TAP_DANCE_ENTRY(KC_NO, KC_NO, KC_NO, KC_NO, 200),
    TAP_DANCE_ENTRY(KC_NO, KC_NO, KC_NO, KC_NO, 200),
    TAP_DANCE_ENTRY(KC_NO, KC_NO, KC_NO, KC_NO, 200),
    TAP_DANCE_ENTRY(KC_NO, KC_NO, KC_NO, KC_NO, 200),
    TAP_DANCE_ENTRY(KC_NO, KC_NO, KC_NO, KC_NO, 200),
    TAP_DANCE_ENTRY(KC_NO, KC_NO, KC_NO, KC_NO, 200),
    TAP_DANCE_ENTRY(KC_NO, KC_NO, KC_NO, KC_NO, 200),
    TAP_DANCE_ENTRY(KC_NO, KC_NO, KC_NO, KC_NO, 200)
};
#endif

// Combo definitions
#define COMBO_ENTRY(k1, k2, k3, k4, result) ((vial_combo_entry_t){.input ={k1, k2, k3, k4}, .output = result})
#if VIAL_COMBO_ENTRIES > 0
const vial_combo_entry_t PROGMEM default_combo_entries[] = {
    COMBO_ENTRY(KC_Q,  KC_W,  KC_NO, KC_NO, KC_TAB),
    COMBO_ENTRY(KC_NO, KC_NO, KC_NO, KC_NO, KC_NO),
    COMBO_ENTRY(KC_NO, KC_NO, KC_NO, KC_NO, KC_NO),
    COMBO_ENTRY(KC_NO, KC_NO, KC_NO, KC_NO, KC_NO),
    COMBO_ENTRY(KC_NO, KC_NO, KC_NO, KC_NO, KC_NO),
    COMBO_ENTRY(KC_NO, KC_NO, KC_NO, KC_NO, KC_NO),
    COMBO_ENTRY(KC_NO, KC_NO, KC_NO, KC_NO, KC_NO),
    COMBO_ENTRY(KC_NO, KC_NO, KC_NO, KC_NO, KC_NO)
};
#endif

// Macro buffer
const uint8_t PROGMEM default_macro_buffer[] = {
    
};

// Key Override definitions
#if VIAL_KEY_OVERRIDE_ENTRIES > 0
const vial_key_override_entry_t default_key_override_entries[] = {
    {
        KC_NO, // trigger key
        KC_NO, // replacement key
        0xffff, // layer mask
        0, // trigger mods
        0, // negative mod mask
        0, // suppressed mods
        0 // options
    },
    {
        KC_NO, // trigger key
        KC_NO, // replacement key
        0xffff, // layer mask
        0, // trigger mods
        0, // negative mod mask
        0, // suppressed mods
        0 // options
    },
    {
        KC_NO, // trigger key
        KC_NO, // replacement key
        0xffff, // layer mask
        0, // trigger mods
        0, // negative mod mask
        0, // suppressed mods
        0 // options
    },
    {
        KC_NO, // trigger key
        KC_NO, // replacement key
        0xffff, // layer mask
        0, // trigger mods
        0, // negative mod mask
        0, // suppressed mods
        0 // options
    }
};
#endif

// Initialize Vial dynamic items
void __real_dynamic_keymap_reset(void);
void __wrap_dynamic_keymap_reset(void) {
    __real_dynamic_keymap_reset();

#if VIAL_TAP_DANCE_ENTRIES > 0
    for (size_t i = 0; i < sizeof(default_tap_dance_entries) / sizeof(default_tap_dance_entries[0]); ++i) {
        dynamic_keymap_set_tap_dance(i, &default_tap_dance_entries[i]);
    }
#endif
#if VIAL_COMBO_ENTRIES > 0
    for (size_t i = 0; i < sizeof(default_combo_entries) / sizeof(default_combo_entries[0]); ++i) {
        dynamic_keymap_set_combo(i, &default_combo_entries[i]);
    }
#endif
#if VIAL_KEY_OVERRIDE_ENTRIES > 0
    for (size_t i = 0; i < sizeof(default_key_override_entries) / sizeof(default_key_override_entries[0]); ++i) {
        dynamic_keymap_set_key_override(i, &default_key_override_entries[i]);
    }
#endif
#ifdef QMK_SETTINGS
    qmk_settings_t qs;
    uint8_t* p_qs = (uint8_t*)&qs;
    for (size_t i = 0; i < sizeof(qs); ++i) {
        p_qs[i] = dynamic_keymap_get_qmk_settings(i);
    }
    #ifdef VIAL_DEFAULT_TAPPING
        qs.tapping = VIAL_DEFAULT_TAPPING;
    #endif
    #ifdef VIAL_DEFAULT_AUTO_SHIFT
        qs.auto_shift = VIAL_DEFAULT_AUTO_SHIFT;
    #endif
    #ifdef DEFAULT_GRAVE_ESC_OVERRIDE
        qs.grave_esc_override = DEFAULT_GRAVE_ESC_OVERRIDE;
    #endif

    for (size_t i = 0; i < sizeof(qs); ++i) {
        dynamic_keymap_set_qmk_settings(i, p_qs[i]);
    }

    #ifdef DEFAULT_KEYMAP_EECONFIG
        keymap_config.raw = DEFAULT_KEYMAP_EECONFIG;
        eeconfig_update_keymap(keymap_config.raw);
    #endif

    qmk_settings_init();
#endif 

    uint16_t const macro_buffer_size = MIN(sizeof(default_macro_buffer), dynamic_keymap_macro_get_buffer_size());
    dynamic_keymap_macro_set_buffer(0, macro_buffer_size, (uint8_t *)default_macro_buffer);
}

/* GENERATED CODE END */


/* USER CODE BEGIN */
// ==== 可変パラメータ（必要に応じて調整） =========================
static const uint16_t kCpiList[]   = { 200, 400, 800, 1600, 3200 };
static const int8_t   kAngleList[] = { -90,-60,-45,-30,-15,0,15,30,45,60,90 };
static const int16_t COS_Q10[] = {    0,  512,  724,  887,  990, 1024,  990,  887,  724,  512,    0};
static const int16_t SIN_Q10[] = {-1024, -887, -724, -512, -259,    0,  259,  512,  724,  887, 1024};
static const uint8_t  kScrDivList[]= { 3,4,5,6,7,8 }; // 2^div のシフト量

// 「CPI」はここでは移動量のソフト倍率で再現（ハードCPIは後述）
#define CPI_BASE 800  // 800cpi を基準1.0として扱う

// ==== EEPROM保存（左右まとめて 32bit にパック） ==================
typedef struct {
    uint8_t cpi_idx;     // 0..15
    uint8_t rot_idx;     // 0..15
    uint8_t scr_div_idx; // 0..7
    bool    scr_invert;  // 0/1
    bool    scroll_mode; // 0:cursor 1:scroll
} side_cfg_t;

static side_cfg_t gL, gR;

static inline uint32_t pack_cfg(void) {
    uint32_t v = 0;
    v |= (uint32_t)(gL.cpi_idx     & 0xF)      << 0;
    v |= (uint32_t)(gL.rot_idx     & 0xF)      << 4;
    v |= (uint32_t)(gL.scr_div_idx & 0x7)      << 8;
    v |= (uint32_t)(gL.scr_invert  ? 1 : 0)    << 11;
    v |= (uint32_t)(gL.scroll_mode ? 1 : 0)    << 12;

    v |= (uint32_t)(gR.cpi_idx     & 0xF)      << 13;
    v |= (uint32_t)(gR.rot_idx     & 0xF)      << 17;
    v |= (uint32_t)(gR.scr_div_idx & 0x7)      << 21;
    v |= (uint32_t)(gR.scr_invert  ? 1 : 0)    << 24;
    v |= (uint32_t)(gR.scroll_mode ? 1 : 0)    << 25;
    return v;
}
static inline void unpack_cfg(uint32_t v) {
    gL.cpi_idx     = (v >> 0)  & 0xF;
    gL.rot_idx     = (v >> 4)  & 0xF;
    gL.scr_div_idx = (v >> 8)  & 0x7;
    gL.scr_invert  = ((v >> 11) & 1) != 0;
    gL.scroll_mode = ((v >> 12) & 1) != 0;

    gR.cpi_idx     = (v >> 13) & 0xF;
    gR.rot_idx     = (v >> 17) & 0xF;
    gR.scr_div_idx = (v >> 21) & 0x7;
    gR.scr_invert  = ((v >> 24) & 1) != 0;
    gR.scroll_mode = ((v >> 25) & 1) != 0;
}
static void tb_eeprom_defaults(void) {
    // 左
    gL.cpi_idx     = 2;   // 800cpi
    gL.rot_idx     = 5;   // 0°
    gL.scr_div_idx = 5;   // スクロール弱め
    gL.scr_invert  = false;
    gL.scroll_mode = true;

    // 右（例として左よりさらに弱く・逆スクロール）
    gR.cpi_idx     = 2;   // 800cpi
    gR.rot_idx     = 5;   // 0°
    gR.scr_div_idx = 3;
    gR.scr_invert  = false;
    gR.scroll_mode = false;
}
static void tb_load_eeprom(void) {
    uint32_t raw = eeconfig_read_kb();
    unpack_cfg(raw);

    bool bad =
        gL.cpi_idx     >= ARRAY_SIZE(kCpiList)   ||
        gL.rot_idx     >= ARRAY_SIZE(kAngleList) ||
        gL.scr_div_idx >= ARRAY_SIZE(kScrDivList)||
        gR.cpi_idx     >= ARRAY_SIZE(kCpiList)   ||
        gR.rot_idx     >= ARRAY_SIZE(kAngleList) ||
        gR.scr_div_idx >= ARRAY_SIZE(kScrDivList);

    if (bad) {
        tb_eeprom_defaults();
        eeconfig_update_kb(pack_cfg());
    }
}
static inline void tb_save(void) { eeconfig_update_kb(pack_cfg()); }

// レガシー互換の薄いラッパ（以前の関数名を残したい場合に使用）
static inline void tb_load_eeprom_side(bool _is_left){ (void)_is_left; tb_load_eeprom(); }
static inline void tb_save_eeprom_side(bool _is_left){ (void)_is_left; tb_save(); }

// ==== 2D回転（整数近似） ==========================================
static inline void rotate_xy(int8_t* x, int8_t* y, int8_t deg) {
    int8_t ox = *x, oy = *y;
    switch (deg) {
        case 90:   *x = -oy; *y =  ox; break;
        case -90:  *x =  oy; *y = -ox; break;
        case 45:   *x = (ox - oy); *y = (ox + oy); break;
        case -45:  *x = (ox + oy); *y = (oy - ox); break;
        case 60:   *x = ( -oy*866 + ox*500 )/1000, *y = ( ox*866 + oy*500 )/1000; break;
        case -60:  *x = (  oy*866 + ox*500 )/1000, *y = ( -ox*866 + oy*500 )/1000; break;
        case 30:   *x = ( ox*866 - oy*500 )/1000, *y = ( ox*500 + oy*866 )/1000; break;
        case -30:  *x = ( ox*866 + oy*500 )/1000, *y = ( oy*866 - ox*500 )/1000; break;
        case 15:   *x = ( ox*966 - oy*259 )/1000, *y = ( ox*259 + oy*966 )/1000; break;
        case -15:  *x = ( ox*966 + oy*259 )/1000, *y = ( oy*966 - ox*259 )/1000; break;
        default:   break; // 0°
    }
}
static inline void rotate_xy_idx(int8_t* x, int8_t* y, uint8_t idx) {
    int8_t ox = *x, oy = *y;
    int32_t rx = (int32_t)ox * COS_Q10[idx] - (int32_t)oy * SIN_Q10[idx];
    int32_t ry = (int32_t)ox * SIN_Q10[idx] + (int32_t)oy * COS_Q10[idx];
    rx += (rx >= 0 ? 512 : -512); ry += (ry >= 0 ? 512 : -512); // 四捨五入
    rx >>= 10; ry >>= 10;
    if (rx > 127) rx = 127; else if (rx < -127) rx = -127;
    if (ry > 127) ry = 127; else if (ry < -127) ry = -127;
    *x = (int8_t)rx; *y = (int8_t)ry;
}

// ==== スクロール変換（左右別の蓄積） ==============================
static int v_acc_l = 0, h_acc_l = 0;
static int v_acc_r = 0, h_acc_r = 0;

static void apply_scroll(report_mouse_t* r, bool invert, uint8_t scr_div_idx, bool is_left) {
    int *v_acc = is_left ? &v_acc_l : &v_acc_r;
    int *h_acc = is_left ? &h_acc_l : &h_acc_r;

    int8_t x = r->x, y = r->y;
    // どちらかを0にして1D寄せ
    if (abs((int)x) > abs((int)y)) y = 0; else x = 0;

    if (invert) { x = -x; y = -y; }

    uint8_t div = kScrDivList[scr_div_idx];
    *h_acc += x; *v_acc += y;

    int8_t hs = (int8_t)(*h_acc >> div);
    int8_t vs = (int8_t)(*v_acc >> div);

    if (hs) { r->h += hs; *h_acc -= (hs << div); }
    if (vs) { r->v += vs; *v_acc -= (vs << div); }

    // スクロール時はXYを出さない
    r->x = 0;
    r->y = 0;
}

// ==== 移動量のソフト倍率（左右別） ================================
static int64_t x_acc_l=0, y_acc_l=0, x_acc_r=0, y_acc_r=0;

static void apply_move_scale(report_mouse_t* r, uint16_t cpi, bool is_left) {
    int64_t *xa = is_left ? &x_acc_l : &x_acc_r;
    int64_t *ya = is_left ? &y_acc_l : &y_acc_r;

    *xa += (int64_t)r->x * (int64_t)cpi;
    *ya += (int64_t)r->y * (int64_t)cpi;

    int32_t ox = (int32_t)(*xa / CPI_BASE);
    int32_t oy = (int32_t)(*ya / CPI_BASE);
    if (ox > 127) ox = 127; else if (ox < -127) ox = -127;
    if (oy > 127) oy = 127; else if (oy < -127) oy = -127;

    r->x = (int8_t)ox; r->y = (int8_t)oy;
    *xa -= (int64_t)ox * CPI_BASE;
    *ya -= (int64_t)oy * CPI_BASE;

    // 残差を安全範囲にクリップ（暴走保険）
    const int64_t bound = (int64_t)CPI_BASE * 512;
    if (*xa >  bound) *xa =  bound; if (*xa < -bound) *xa = -bound;
    if (*ya >  bound) *ya =  bound; if (*ya < -bound) *ya = -bound;
}

// ==== カスタムキーコード ==========================================
enum custom_keycodes {
    TB_L_CPI_NEXT = QK_KB_0, TB_L_CPI_PREV,
    TB_L_ROT_NEXT, TB_L_ROT_PREV,
    TB_L_SCR_TOG,  TB_L_SCR_DIV,
    TB_L_SCR_INV,

    TB_R_CPI_NEXT, TB_R_CPI_PREV,
    TB_R_ROT_NEXT, TB_R_ROT_PREV,
    TB_R_SCR_TOG,  TB_R_SCR_DIV,
    TB_R_SCR_INV,
};

// ==== 初期化フック（_user を使用） ================================
void keyboard_post_init_user(void) {
    tb_load_eeprom();
}

// ==== キー処理（押下時）（_user を使用） ==========================
bool process_record_user(uint16_t keycode, keyrecord_t* record) {
    if (!record->event.pressed) return true;

    switch (keycode) {
        // 左
        case TB_L_CPI_NEXT:
            gL.cpi_idx = (gL.cpi_idx + 1) % ARRAY_SIZE(kCpiList); tb_save(); return false;
        case TB_L_CPI_PREV:
            gL.cpi_idx = (gL.cpi_idx + ARRAY_SIZE(kCpiList) - 1) % ARRAY_SIZE(kCpiList); tb_save(); return false;
        case TB_L_ROT_NEXT:
            gL.rot_idx = (gL.rot_idx + 1) % ARRAY_SIZE(kAngleList); tb_save(); return false;
        case TB_L_ROT_PREV:
            gL.rot_idx = (gL.rot_idx + ARRAY_SIZE(kAngleList) - 1) % ARRAY_SIZE(kAngleList); tb_save(); return false;
        case TB_L_SCR_TOG:
            gL.scroll_mode ^= 1; tb_save(); return false;
        case TB_L_SCR_DIV:
            gL.scr_div_idx = (gL.scr_div_idx + 1) % ARRAY_SIZE(kScrDivList); tb_save(); return false;
        case TB_L_SCR_INV:
            gL.scr_invert ^= 1; tb_save(); return false;

        // 右
        case TB_R_CPI_NEXT:
            gR.cpi_idx = (gR.cpi_idx + 1) % ARRAY_SIZE(kCpiList); tb_save(); return false;
        case TB_R_CPI_PREV:
            gR.cpi_idx = (gR.cpi_idx + ARRAY_SIZE(kCpiList) - 1) % ARRAY_SIZE(kCpiList); tb_save(); return false;
        case TB_R_ROT_NEXT:
            gR.rot_idx = (gR.rot_idx + 1) % ARRAY_SIZE(kAngleList); tb_save(); return false;
        case TB_R_ROT_PREV:
            gR.rot_idx = (gR.rot_idx + ARRAY_SIZE(kAngleList) - 1) % ARRAY_SIZE(kAngleList); tb_save(); return false;
        case TB_R_SCR_TOG:
            gR.scroll_mode ^= 1; tb_save(); return false;
        case TB_R_SCR_DIV:
            gR.scr_div_idx = (gR.scr_div_idx + 1) % ARRAY_SIZE(kScrDivList); tb_save(); return false;
        case TB_R_SCR_INV:
            gR.scr_invert ^= 1; tb_save(); return false;
    }
    return true;
}

// ==== COMBINED モードのポインティング処理（_user を使用） =========
report_mouse_t pointing_device_task_combined_user(report_mouse_t left, report_mouse_t right) {
    // 左
    {
        int8_t x = left.x, y = left.y;
        rotate_xy_idx(&x, &y, gL.rot_idx);
        left.x = x; left.y = y;

        if (gL.scroll_mode) {
            apply_scroll(&left, gL.scr_invert, gL.scr_div_idx, true);
        } else {
            apply_move_scale(&left, kCpiList[gL.cpi_idx], true);
        }
    }

    // 右
    {
        int8_t x = right.x, y = right.y;
        rotate_xy_idx(&x, &y, gR.rot_idx);
        right.x = x; right.y = y;

        if (gR.scroll_mode) {
            apply_scroll(&right, gR.scr_invert, gR.scr_div_idx, false);
        } else {
            apply_move_scale(&right, kCpiList[gR.cpi_idx], false);
        }
    }

    return pointing_device_combine_reports(left, right);
}
/* USER CODE END */